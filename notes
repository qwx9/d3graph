- types for references: RValueRef, RRuleRef, RTreeRef
	* no point in complexifying types, just make new ones
	* way to add an update function to fix state when changing RRuleRef/RTreeRef
		. RTreeRef optional update() arg?
- add root, rate, proc, phyl
	* multiple and exclusive values: combination of phyl or proc + data
		=> maybe final phylogeny is refs to phylogeny + op ≠ any phylogeny, proc + data
⇒ this solves everything
- check valid bpp output
- implement list based on predicate (model list based on alphabet)
	* multiple rule tables and refs between them
	* distribution table, model tables by type
	* refs to trees of rules, mutable or not
	* these things can be intermixed for more complex situations and weird models
		- any model with any whatever
		- so, associative arrays? arrays with all (redundant) possibilities?
		  array of concatenated sets?

- error checking
	* must have one phylogeny defined
		- which in turn implies model, data, etc
	* input stuff must have a (non-empty) path= param
- add fourre-tout toplevel options
- output ui result and edit prior to submit ⇒ textarea
	* manually upload bpp file ⇒ load into text area
	* then submit as is
	* make sure we don't overwrite gui state if the text was changed manually
- start thinking about ruleset spec language and transpilation to ts
- visuals/css: minimal css-only framework
	* tooltips for description/type/information/links to doc
	* left pane: list of model components
	* right pane: onselect, description
	* hide unused/uninitialized primitives?
	* do as little css customization as possible
	* file input shit sucks


- val.ts: ValueElem .el in interface and add standard .set() and .pop()/.nuke()/etc


- more stuff + bppml specific options
- aliases
	* forward/backward aliases?


- variable naming in bpp: model1-2-3: model1 parameter _1, see how shit is automatically named
	. important for references
	. HKY85.kappa_1, not model1.kappa
	. but in spec: process1=Nonhomogeneous(model1=1, model2=2)
		tree=2, rate=1, etc.
- documentation, links towards
	* note: as stateless as possible (which also means redundancies)
	* root elements are treated differently and full of exceptions...
