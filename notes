- finish implementing val.ts
- skeleton dom.*.ts
- fix compilation
- reimplement dom shit as before
- test
- file browser for VFileObj
- submissal
	* seems fairly simple
	* mdn: sending forms through javascript
- references
	* if a rule marks something as referable, reference a table of such available refs
	* and whenever a new one is created, add it to the table
- aliases
- error checking
- ruleset generation
- visuals/css
- read evolutionary model from file



- serialization
	* each expression is compiled into a line of text
	* process is recursive and now very simple thanks to the data structures
	* each line is appended to a big string
	* at the end, the string and files to upload are submitted to the sv in a single request
- references to objects and aliases
- error checking: tbd
	* either traverse the trees on submit, generate constraints and remove those met on the fly, then emit those that remain
	* or keep state around without recalculating anything, but more bug-prone
- ruleset generation: tbd
	* right now, giant object of objects, easy to fuck up
	* will instead have a file with the simplest possible format
	* transpiled to typescript, all ts concatenated into app.ts, then transpile to app.js
- remains
	* better visuals with css
	* error checking
	* ruleset generation
	* extra stuff
		. reading ready-made model from input text file



- automatic error checks for data type entry

- set ref if there's children -> children remain, state fucked
- numeric opts can't reference other values
- Rule refs are not fixed

- if you add a sym, Rule might be updated, but dom options are not
- remove obj -> syms/refs/objs aren't renamed (or [i] text)
	* so if you add two models, remove [1], add another, both will be indexed 2
- alphabet: add stuff with opts -> can remove -> set to other -> opts remain


- error checks, keep track of inconsistencies
	* thus far, not much to actually do here

- removing elements
	* need to remove each sym in the element's tree from Rule[]
- would have to fix all references in our js shit: Rule, Sym

- error area
- synthesize text file (show it in a text area at end)
- add text area with result, immediately write resulting config there (just references for now)

- add information to Rule: existing instances of the given Rule (-> Sym[])
	* in definition: .ref → ref into a ruletab[], and .canalias → list existing instances of THAT Rule (or self)
	* Rule → will have to allow multiple (exclusive) values: phylogeny: combination of phylogenies or proc+data, etc

- required arguments -> auto add

- file selection and upload
- sending shit to server

- completely dissociate data from visualisation (dom operations) → set functions for drawing on update
- start thinking about css and layout (vertical tabs, etc)
- tooltips for type and description
- hide unused/uninitialized primitives
- visual: [primitive type][+] -> hover: desc, click: dropdown menu, select: spawn
- load ruleset and metadata (descriptions etc) from file or compile multiple ts -> one js
- or even simple model spec format in root dir -> compile to ts -> compile to js

- submit ready-made bpp config file -> param frontend

- primitive: select add or setone on construction (function pointer), less confusing
- vis: maybe:
	add model:
	model$i = $model() [parms]
	click [parms] -> <select>

	PRIMLABEL [select][+]
	[x]model$i = $model(parm[x]) [parms]
		div
			span
				button: [x]
				span: label: model$i = $model
				span: (
					
				span: )
				select?: parms
	compiled sym text decomposed into label (model$i), objname ($model), params[]
	call this an Expr, not Sym
	=> primitive contains Expr's
	expr.compile() → .text + attrs with each component
		if setting an alias, needs to be multiple lines
	maybe even dispense with primitives, just have exprs of different types
		model, optim, alphabet, etc
	think outside of vis for now, dispense with all the html shit in the index file
	in fact, we should remove all that shit


- data types: bool, string, bounded real (]0,1[ etc), proportion, etc.
- frequency set: must select one (default), can't just dangle
- implement cross-object references: seq, tree, model, etc.
	. practically everything can be referenced
	. but referencing another object is restricted
- remove objects
- add submit -> compile text file and show result
- error checking: keep track of what's needed: constraints unmet
	. we know ahead of time what's missing
	. or do we? what happens if we add aliases etc?
	. might not be an issue
	. in other words, barring other problems during compilations,
	we can warn of missing shit ahead of time,
	just by keeping track of a todo list
	. update: delete/add/modify shit
- add a way to name and reference tree nodes
	. default names, or indices from files?
	. no error checking since we can't parse tree anyway
	. just always use indices for nodes?
	. user could specify tree shape?
- implement selecting a file, saving filepath
- variable naming in bpp: model1-2-3: model1 parameter _1, see how shit is automatically named
	. important for references
	. HKY85.kappa_1, not model1.kappa
	. but in spec: process1=Nonhomogeneous(model1=1, model2=2)
		tree=2, rate=1, etc.
- actually submit data to server
- serialization + pov of model collections -> verification/inconsistance: suppression, ajout de modeles, ref, etc
- if there's an error on input which bppml detects immediately:
	. show query page with same parametrization and error messages
	. allow basically recompiling the config and sending new files
		* or keeping old otherwise
- implement all options from bpp manual
	. some are hierarchical: one alphabel -> set of possible models
- fix seldom/datdom silliness
- index1, index2: accessoire
- output mandatory .profile to ease postprocessing
- null checks, other error checking, asserts
- presentation idea:
	. tabs?
	. left pane: list of model components
	. right pane: onselect, description
	. group components this way, avoids all on one page
	. still, only representation, still need data and relationships
- could also hide/unhide obj panes via css or w/e
- csshit for pretty
- re-check visualization if time remains
- notes
	. bypass cache: ^F5
	. alert(string);
