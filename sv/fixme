/* FIXME: steps
 * - implement alpha, seq, tree, rate, root forms
 * - implement python script compiling html and render this data-driven
 */

/* FIXME: seq validity: check that the alphabet is correct?
 * can be heavy client side, but then would avoid server load
 * but then responsiveness would take a hit
 * problem: too many formats and some we can't handle
 * should secure and send to server and either return error or detect that all is ok
 * if error, should not keep data if user leaves page (or other conditions?)
 *	must prevent any server-side meddling
 */

/* FIXME: submit validation
 * form with onsubmit="return(validate());" with validate our function
 * if valid, compile and set content of form before submitting
 * content = form + multiple files
 */

/* FIXME: select file to upload, do not display more than file name
 * how to upload separate files: <input type="file" multiple> within form
 * => seqs, trees
 */

/* FIXME: data-oriented approach: don't hardcode anything in html/js
 * rather, compile html beforehand with a script just like the typescript
 * then get stuff from it in the js
 * hybrid: script parsing json into html and loaded into js, but now there's a vector for error
 * synthesize the html for the different divs using a python/R lib or w/e
 *	or if it's just a simple file with the hierarchy/key-value, can use awk etc
 *	but others won't be able to change it because ain't no one know awk
 *	just a json then + python, we already use flask
 */

/* FIXME: input: see biopp manual for all possibilities
 * encode in some key-value store, insert in html, write general code here
 * most if not all is hierarchical
 * alphabet=Codon -> all seqs are prot -> specific models -> specific params
 * given model -> specific options and possibilities
 */

- demo: just give a compiled app.js and index.html
- add all options for seq => json
- add a single model for now => json
- hide defaults, add a way to change them
- add a way to bind aliases
- add binding to proc and phyl
- add submit -> compile text file and show result
- implement suboptions
- error checking
	. we know ahead of time what's missing
	. or do we? what happens if we add aliases etc?
	. might not be an issue
	. in other words, barring other problems during compilations,
	we can warn of missing shit ahead of time,
	just by keeping track of a todo list
- add/set: generalize
	. read possible primitives from html
	. each with some kind of generic add/set

- index1, index2: accessoire



- null checks
- WE NEED TO GET A TEXT FILE GENERATED WITH ALL THIS SHIT, (especially?) even for the demo
- notes
	. bypass cache: ^F5
	. alert(string);
- json dict with all rules for 8 primitives
- generation: html with all basic elements, or js/ts with all basic elements
- why not just go with underlying graph model, regardless of representation?
	. like, adjacency lists for dom objects, visible or not
- idea:
	. left pane: list of model components
	. right pane: onselect, description
	. group components this way, avoids all on one page
	. still, only representation, still need data and relationships
- alpha:
	. all possibilities
- addtree:
	. parse nodes to be able to attribute models?
	. tree formats
		* no parser for nexus files
		* many for newick
		* 1-2 for nhx: nhx.js, tnt.newick
- addmodel
	. add simple homogenous model: json with name and variable dicts
	. select model
	. add params values for non-defaults (hash tables)
- addroot
	. reference a tree
- addproc
	. reference model + tree, etc
- addphyl
	. reference proc + data
